// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: outbox_msg.sql

package sqlc

import (
	"context"
	"encoding/json"
	"time"

	"github.com/google/uuid"
)

const outboxMsgCreate = `-- name: OutboxMsgCreate :exec
INSERT INTO outbox_messages (
	topic,
	headers,
	payload,
	partition_key,
	created_at,
	processed_at,
	error
) VALUES (
	$1,
	$2,
	$3,
	$4,
	$5,
	$6,
	$7
)
`

type OutboxMsgCreateParams struct {
	Topic        string           `json:"topic"`
	Headers      *json.RawMessage `json:"headers"`
	Payload      json.RawMessage  `json:"payload"`
	PartitionKey *string          `json:"partition_key"`
	CreatedAt    time.Time        `json:"created_at"`
	ProcessedAt  *time.Time       `json:"processed_at"`
	Error        *string          `json:"error"`
}

func (q *Queries) OutboxMsgCreate(ctx context.Context, db DBTX, arg OutboxMsgCreateParams) error {
	_, err := db.Exec(ctx, outboxMsgCreate,
		arg.Topic,
		arg.Headers,
		arg.Payload,
		arg.PartitionKey,
		arg.CreatedAt,
		arg.ProcessedAt,
		arg.Error,
	)
	return err
}

const outboxMsgListUnprocessed = `-- name: OutboxMsgListUnprocessed :many
SELECT
	id,
	topic,
	headers,
	payload,
	partition_key
FROM outbox_messages
WHERE processed_at IS NULL
ORDER BY created_at ASC
LIMIT $1
FOR UPDATE SKIP LOCKED
`

type OutboxMsgListUnprocessedRow struct {
	ID           uuid.UUID        `json:"id"`
	Topic        string           `json:"topic"`
	Headers      *json.RawMessage `json:"headers"`
	Payload      json.RawMessage  `json:"payload"`
	PartitionKey *string          `json:"partition_key"`
}

func (q *Queries) OutboxMsgListUnprocessed(ctx context.Context, db DBTX, batchsize int32) ([]OutboxMsgListUnprocessedRow, error) {
	rows, err := db.Query(ctx, outboxMsgListUnprocessed, batchsize)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []OutboxMsgListUnprocessedRow{}
	for rows.Next() {
		var i OutboxMsgListUnprocessedRow
		if err := rows.Scan(
			&i.ID,
			&i.Topic,
			&i.Headers,
			&i.Payload,
			&i.PartitionKey,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
